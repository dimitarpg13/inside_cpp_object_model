The Semantics of Constructors

One of the most often heard complaints about C++ is that the compiler does things 
behind the programmer's back. Conversion operators are the example most often
cited. Here is an example of an attempt to support a scalar test of an iostream class 
object such as:

```cpp
if ( cin ) ...
```

For ```cin``` to evaluate to true/false scalar value, the iostream library designer
 first defined an ```operator int()``` conversion operator. This worked fine in 
well-behaved instances such as this example, but it behaved in a somewhat surprising
 manner under the following programmer error:

```cpp
// oops: meant cout, not cin
cin << intVal;
```

The designer, of course meant ```cout```, not ```cin```. The type-safe nature of the 
class hierarchy is supposed to catch this misapplication of the output operator.
The compiler, however, in a somewhat materialistic way, prefers to find a correct
interpretation, if there is one, rather than flag the program as bad. In this case,
the built-in left-shift operator can be applied if only ```cin``` is convertible 
to an integral value. The compiler checks the available conversion operators. 
It finds the ```operator int()``` instance, the very thing it was looking for. 
The left-shift operator can now be applied - if not successfully, at least legally:

```cpp
// oops: not quite what the programmer intended
int temp = cin.oiperator int();
temp << intVal;
``` 

The library designer resolved this unexpected behavior by replacing the 
```operator int()``` instance with ```operator void* ()```. While errors of this
sort are an embarassment, the absence of an implicit class conversion facility would 
be sorely missed. The example of the original String class was given by Stroustrup
as a motivation: without implicit conversion support, the String library would have
had to replicate all the C library functions that were expecting a string.
The danger of applying a user-defined conversion operator implicitly by the compiler
is clear. Therefore the keyword ```explicit``` was introduced thereby giving the 
programmer a method by which to suppress application of a single argument constructor
as a conversion operator. Conversion operators in practice are difficult to be used
in a predictable, well-behaved manner. Introduction of conversion operators should be
made judiciously, tested rigorously, and at the first sign of unusual program activity
brought in for questioning.

The problem, however, is more in the nature of the compiler taking your intentions far
too literally than of its actually doing something behind your back. These kind of
implicit activities are much more likely to occur in support of memberwise 
initialization or in the application of what is referred to as the named return value
optimization (NRV). 

Default Constructor Construction

Default constructor are generated by the compiler where needed. Consider for example
the following fragment:

```cpp
class Foo { public: int val; Foo *pnext; };

void foo_bar()
{
   // Oops: program needs bar's members zeroed out
   Foo bar;
   if ( bar.val || bar.pnext )
      // ... do something
   // ...
}
```

In this example, correct program semantics requires of ```Foo``` a default constructor
that initializes its two members to zero. Does this fragment, then, fulfill the 
requirement of _needed_ as stated in the definition? The short answer is no. The 
distinction is that between the needs of the program and the needs of the implmentation.
A program's need for default constructor is the responsibility of the programmer; in
this case the individual who designed the class ```Foo```. A default constructor is not
synthesized for this code fragment.
Note: Global objects are guaranteed to have their associated memory "zeroed out" at 
program start-up. Local objects allocated on the program stack and heap objects on the
free-store do not have their associated memory zeroed out; rather, the memory retains 
the arbitrary bit pattern of its previous use.

Default constructor is synthesized only when the implementation needs it. Moreover, 
the synthesized constructor performs only those activities required by the 
implementation. That is, even if there were a need to synthesize a default constructor
for class ```Foo```, that constructor would not include code to zero out the two data
members ```val``` and ```pnext```. For the previous program fragment to execute correctly,
the designer of class ```Foo``` needs to provide an explicit default constructor that 
properly initializes the class's two members. 

The C++ standard (ISO C++ 95) states the following:

_If there is no user-defined constructor for class X, a default constructor is implicitly
declared. A constructor is **trivial** if it is an implicitly declared default constructor_

The standard then goes on to iterate the conditions under which the implicit default 
constructor is considered trivial. A nontrivial default constructor is one that is needed
by the implementation and, if necessary, is synthesized by the compiler. The next four 
sections look at the four conditions under which the default constructor is non-trivial.

Member Class Object with Default Constructor



