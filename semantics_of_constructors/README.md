The Semantics of Constructors

One of the most often heard complaints about C++ is that the compiler does things 
behind the programmer's back. Conversion operators are the example most often
cited. Here is an example of an attempt to support a scalar test of an iostream class 
object such as:

```cpp
if ( cin ) ...
```

For ```cin``` to evaluate to true/false scalar value, the iostream library designer
 first defined an ```operator int()``` conversion operator. This worked fine in 
well-behaved instances such as this example, but it behaved in a somewhat surprising
 manner under the following programmer error:

```cpp
// oops: meant cout, not cin
cin << intVal;
```

The designer, of course meant ```cout```, not ```cin```. The type-safe nature of the 
class hierarchy is supposed to catch this misapplication of the output operator.
The compiler, however, in a somewhat materialistic way, prefers to find a correct
interpretation, if there is one, rather than flag the program as bad. In this case,
the built-in left-shift operator can be applied if only ```cin``` is convertible 
to an integral value. The compiler checks the available conversion operators. 
It finds the ```operator int()``` instance, the very thing it was looking for. 
The left-shift operator can now be applied - if not successfully, at least legally:

```cpp
// oops: not quite what the programmer intended
int temp = cin.oiperator int();
temp << intVal;
``` 

The library designer resolved this unexpected behavior by replacing the 
```operator int()``` instance with ```operator void* ()```. While errors of this
sort are an embarassment, the absence of an implicit class conversion facility would 
be sorely missed. The example of the original String class was given by Stroustrup
as a motivation: without implicit conversion support, the String library would have
had to replicate all the C library functions that were expecting a string.
The danger of applying a user-defined conversion operator implicitly by the compiler
is clear. Therefore the keyword ```explicit``` was introduced thereby giving the 
programmer a method by which to suppress application of a single argument constructor
as a conversion operator. Conversion operators in practice are difficult to be used
in a predictable, well-behaved manner. Introduction of conversion operators should be
made judiciously, tested rigorously, and at the first sign of unusual program activity
brought in for questioning.

The problem, however, is more in the nature of the compiler taking your intentions far
too literally than of its actually doing something behind your back. These kind of
implicit activities are much more likely to occur in support of memberwise 
initialization or in the application of what is referred to as the named return value
optimization (NRV). 

Default Constructor Construction

Default constructor are generated by the compiler where needed. Consider for example
the following fragment:

```cpp
class Foo { public: int val; Foo *pnext; };

void foo_bar()
{
   // Oops: program needs bar's members zeroed out
   Foo bar;
   if ( bar.val || bar.pnext )
      // ... do something
   // ...
}
```

In this example, correct program semantics requires of ```Foo``` a default constructor
that initializes its two members to zero. Does this fragment, then, fulfill the 
requirement of _needed_ as stated in the definition? The short answer is no. The 
distinction is that between the needs of the program and the needs of the implmentation.
A program's need for default constructor is the responsibility of the programmer; in
this case the individual who designed the class ```Foo```. A default constructor is not
synthesized for this code fragment.
Note: Global objects are guaranteed to have their associated memory "zeroed out" at 
program start-up. Local objects allocated on the program stack and heap objects on the
free-store do not have their associated memory zeroed out; rather, the memory retains 
the arbitrary bit pattern of its previous use.

Default constructor is synthesized only when the implementation needs it. Moreover, 
the synthesized constructor performs only those activities required by the 
implementation. That is, even if there were a need to synthesize a default constructor
for class ```Foo```, that constructor would not include code to zero out the two data
members ```val``` and ```pnext```. For the previous program fragment to execute correctly,
the designer of class ```Foo``` needs to provide an explicit default constructor that 
properly initializes the class's two members. 

The C++ standard (ISO C++ 95) states the following:

_If there is no user-defined constructor for class X, a default constructor is implicitly
declared. A constructor is **trivial** if it is an implicitly declared default constructor_

The standard then goes on to iterate the conditions under which the implicit default 
constructor is considered trivial. A nontrivial default constructor is one that is needed
by the implementation and, if necessary, is synthesized by the compiler. The next four 
sections look at the four conditions under which the default constructor is non-trivial.

Member Class Object with Default Constructor

If a class without any constructors contains a member object of a class with a default
constructor, the implicit default constructor of the class is nontrivial and the 
compiler needs to synthesize a default constructor for the containing class. This 
synthesis, however, takes place only if the constructor actually needs to be invoked.

An interesting question, then: Given the separate compilation model for C++, how does the
compiler prevent synthesizing multiple default constructors, for example, one for file A.C
and a second for file B.C? In practice, this is solved by having the synthesized default
constructor, copy constructor, destructor and/or assignment copy operator defined as inline.
An inline function has static linkage and is therefore not visible outside the file within
which it is synthesized. If the function is too complex to be inlined by the implementation,
an explicit non-inline static instance is synthesized. 

For example, in the following code fragment, the compiler synthesizes a default constructor
for a class ```Bar```:

```cpp

class Foo { public: Foo(), Foo( int ) ... };
class Bar { public: Foo foo; char *str; };

void foo_bar() {
   Bar bar; // Bar::foo must be initialized here
   if ( str ) { } ...
}
```

The synthesized default constructor contains the code necessary to invoke the class ```Foo```
default constructor on the member object ```Bar::foo```, but it does not generate any code to 
initialize ```Bar::str```. Initialization of ```Bar::foo``` is the compiler's responsibility;
initialization of ```Bar::str``` is the programmer's. The synthesized default constructor might
look as follows:

```cpp

// possible synthesis of Bar default constructor
// invoke Foo default constructor for member foo
inline Bar::Bar()
{
   // pseudo C++ code
   foo.Foo::Foo();
}
```

Again, note that the synthesized default constructor meets only the needs of the implementation,
not the needs of the program. For the program fragment to execute correctly, the character 
pointer ```str``` also needs to be initialized. Let us assume the programmer provides for the
initialization of ```str``` via the following default constructor:

```cpp
// programmer defined default constructor
Bar::Bar() { str = 0; }
```

Now the program need is fulfilled, but the implementation need to initialize the member object 
```foo``` still remains. Because the default constructor is explicitly defined, the compiler 
cannot synthesize a second instance to do its work.

Consider the case of each constructor defined for a class containing one or more member class
objects for which a default constructor must be invoked. In this case, the compiler augments
the existing constructors, inserting code that invokes the necessary default constructors 
prior to the execution of the user code. In the previous example, the resulting augmented 
constructor might look as follows:

```cpp
// Augmented default constructor
// Pseudo C++ code
Bar::Bar()
{
   foo.Foo::Foo(); // augmented compiler code
   str = 0;        // explicit user code
}
```

What happens if there are multipe class member objects requiring constructor initialization?
The language requires that the constructors be invoked in the order of member declaration 
within the class. This is accomplished by the compiler. It inserts code within each constructor
invoking the associated default constructors for each member in the order of the member 
declaration. This code is inserted just prior to the explicitly supplied user code. For 
example, say we have the following three classes:

```cpp
class Dopey { public: Dopey(); ... };
class Sneezy { public: Sneezy ( int ); Sneezy(); ... };
class Bashful { public: Bashful () ... };

``` 

and a containing class ```Snow_White```:

```cpp
class Snow_White {
public:
   Dopey dopey;
   Sneezy sneezy;
   Bashful bashful;
   // ...
private:
   int mumble;
};

```

If ```Snow_White``` does not define a default constructor, a nontrivial default constructor
is synthesized that invokes the three default constructors of Dopey, Sneezy and Bashful in
that order. If, on other hand, ```Snow_White``` defines the following default constructor:

```cpp
// programmer coded default constructor
Snow_White::Snow_White () : sneezy( 1024 )
{
   mumble = 2048;
}
```
it is augmented as follows:

```cpp
// Compiler augmented default constructor
// Pseudo C++ Code
Snow_White::Snow_White()
{
   // insertion of member class object
   // constructor invocations
   dopey.Dopey::Dopey();
   sneezy.Sneezy::Sneezy( 1024 );
   bashful.Bashful::Bashful();

   // explicit user code
   mumble = 2048;
}
```

The interaction of invoking implicit default constructors with that of invoking 
constructors explicitly listed within the member initialization list is discussed later.

Base Class With Default Constructor

Similarly, if a class without any constructors is derived from a base class containing
a default constructor, the default constructor for the derived class is considered 
non-trivial and so needs to be synthesized. The synthesized default constructor of the
derived class invokes the default constructor of each of its immediate base classes in
the order of their declaration. To a subsequently derived class, the synthesized 
constructor appears no different than that of an explicitly provided default constructor.

What if the designer provides multiple constructors but no default constructor? The
compiler augments each constructor with the code necessary to invoke all required default
constructors. However, it does not synthesize a default constructor because of the 
presence of the other user-supplied constructors. If member class objects with default
constructors are also present, these default constructors are also invoked-after the 
invocation of all base class constructors.

Class with a Virtual Function

There are two additional cases in which a synthesized default constructor is needed:

1. The class either declares (or inherits) a virtual function
2. The class is derived from an inheritance chain in which one or more base classes
are virtual

In both cases, in the absence of any declared constructors, implementation bookkeeping
necessitates the synthesis of a default constructor. For example, given the following
code fragment:

```cpp
class Widget {
public:
   virtual void flip() = 0;
   // ...
};

void flip( const Widget& widget ) { widget.flip(); }

// presuming Bell and Whistle are drived from Widget
void foo() {
   Bell b; Whistle w;
   flip( b );
   flip( w );
}
```

the following two class "augmentations" occur during compilation:

1. A virtual function table (referred to as the class vtbl) 
is generated and populated with the addresses of the active virtual functions for that class.

2. Within each class object, an additional pointer member (the _vptr_) is synthesized to hold the 
address of the associated class _vtbl_. 

In addition, the virtual invocation of ```widget.flip()``` is rewritten to make use of ```widget```'s
_vptr_ and ```flip()```'s entry into the associated _vtbl_:

```cpp
// simplified transformation of virtual invocation:
widget.flip()
   ( * widget.vptr[ 1 ] ) ( &widget )
```
where
    * ```l``` represents ```flip()```'s fixed index into the virtual table, and
    * ```&widget``` represents the ```this``` pointer to be passed to the particular
invocation of ```flip()```.

For this mechanism to work, the computer must initialize the _vptr_ of each ```Widget``` object 
(or the object of a class derived from ```Widget```) with the address of the appropriate 
virtual table. For each constructor the class defines, the compiler inserts code that does just
that. In classes that do not declare any constructors, the compiler synthesizes a default
constructor in order to correctly initialize the _vptr_ of each class object. 

Class with a Virtual Base Class

Virtual base class implementations vary widely across compilers. However, what is common to each
implementation is the need to make the virtual base class location within each derived class
object available at runtime. For example, in the following program fragment:

```cpp
class X { public: int i; };
class A : public virtual X { public: int j; };
class B : public virtual X { public: double d; };
class C : public A, public B { public: int k; };
// cannot resolve location of pa->X::i at compile-time
void foo ( const A* pa ) { pa->i = 1024; }

main() {
   foo( new A );
   foo( new C );
   // ...
}
```

the compiler cannot fix the physical offset of ```X::i``` accessed through ```pa``` within ```foo()```,
since the actual type of ```pa``` can vary with each of ```foo()```'s invocations. Rather, the 
compiler must transform the code doing the access so that the resolution of ```X::i``` can be 
delayed until runtime. In the original _cfront_ implementation, for example, this is accomplished by
inserting a pointer to each of the virtual base classes within the derived class object. 
All reference and pointer access of a virtual base class is chieved through the associated pointer.
In our example, ```foo()``` might be rewritten as follows under this implementation strategy:

```cpp
// possible compiler transformation
void foo( const A* pa ) { pa->__vbcX->i = 1024; } 
```
where ```__vbcX``` represents the compiler-generated pointer to the virtual base class ```X```.

The initialization of ```__vbcX``` (or whatever implementation mechanism is used) is accomplished
during the construction of the class object. For each constructor the class defines, the 
compiler inserts code that permits runtime access of each virtual base class. In classes that do
not declare any constructors, the compiler needs to synthesize a default constructor.


