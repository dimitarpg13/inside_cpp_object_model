The Semantics of Constructors

One of the most often heard complaints about C++ is that the compiler does things 
behind the programmer's back. Conversion operators are the example most often
cited. Here is an example of an attempt to support a scalar test of an iostream class 
object such as:

```cpp
if ( cin ) ...
```

For ```cin``` to evaluate to true/false scalar value, the iostream library designer
 first defined an ```operator int()``` conversion operator. This worked fine in 
well-behaved instances such as this example, but it behaved in a somewhat surprising
 manner under the following programmer error:

```cpp
// oops: meant cout, not cin
cin << intVal;
```

The designer, of course meant ```cout```, not ```cin```. The type-safe nature of the 
class hierarchy is supposed to catch this misapplication of the output operator.
The compiler, however, in a somewhat materialistic way, prefers to find a correct
interpretation, if there is one, rather than flag the program as bad. In this case,
the built-in left-shift operator can be applied if only ```cin``` is convertible 
to an integral value. The compiler checks the available conversion operators. 
It finds the ```operator int()``` instance, the very thing it was looking for. 
The left-shift operator can now be applied - if not successfully, at least legally:

```cpp
// oops: not quite what the programmer intended
int temp = cin.oiperator int();
temp << intVal;
``` 

The library designer resolved this unexpected behavior by replacing the 
```operator int()``` instance with ```operator void* ()```. While errors of this
sort are an embarassment, the absence of an implicit class conversion facility would 
be sorely missed. The example of the original String class was given by Stroustrup
as a motivation: without implicit conversion support, the String library would have
had to replicate all the C library functions that were expecting a string.
The danger of applying a user-defined conversion operator implicitly by the compiler
is clear. Therefore the keyword ```explicit``` was introduced thereby giving the 
programmer a method by which to suppress application of a single argument constructor
as a conversion operator. Conversion operators in practice are difficult to be used
in a predictable, well-behaved manner. Introduction of conversion operators should be
made judiciously, tested rigorously, and at the first sign of unusual program activity
brought in for questioning.

The problem, however, is more in the nature of the compiler taking your intentions far
too literally than of its actually doing something behind your back. These kind of
implicit activities are much more likely to occur in support of memberwise 
initialization or in the application of what is referred to as the named return value
optimization (NRV). 

Default Constructor COnstruction

Default constructor are generated by the compiler where needed. Consider for example
the following fragment:

```cpp
class Foo { public: int val; Foo *pnext; };

void foo_bar()
{
   // Oops: program needs bar's members zeroed out
   Foo bar;
   if ( bar.val || bar.pnext )
      // ... do something
   // ...
}
```



